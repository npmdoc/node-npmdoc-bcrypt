<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/kelektiv/node.bcrypt.js#readme"

    >bcrypt (v1.0.2)</a>
</h1>
<h4>A bcrypt library for NodeJS.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.bcrypt">module bcrypt</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bcrypt.compare">
            function <span class="apidocSignatureSpan">bcrypt.</span>compare
            <span class="apidocSignatureSpan">(data, hash, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bcrypt.compareSync">
            function <span class="apidocSignatureSpan">bcrypt.</span>compareSync
            <span class="apidocSignatureSpan">(data, hash)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bcrypt.genSalt">
            function <span class="apidocSignatureSpan">bcrypt.</span>genSalt
            <span class="apidocSignatureSpan">(rounds, ignore, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bcrypt.genSaltSync">
            function <span class="apidocSignatureSpan">bcrypt.</span>genSaltSync
            <span class="apidocSignatureSpan">(rounds)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bcrypt.getRounds">
            function <span class="apidocSignatureSpan">bcrypt.</span>getRounds
            <span class="apidocSignatureSpan">(hash)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bcrypt.hash">
            function <span class="apidocSignatureSpan">bcrypt.</span>hash
            <span class="apidocSignatureSpan">(data, salt, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bcrypt.hashSync">
            function <span class="apidocSignatureSpan">bcrypt.</span>hashSync
            <span class="apidocSignatureSpan">(data, salt)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bcrypt.</span>promises</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bcrypt.promises">module bcrypt.promises</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bcrypt.promises.promise">
            function <span class="apidocSignatureSpan">bcrypt.promises.</span>promise
            <span class="apidocSignatureSpan">(fn, context, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bcrypt.promises.reject">
            function <span class="apidocSignatureSpan">bcrypt.promises.</span>reject
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bcrypt" id="apidoc.module.bcrypt">module bcrypt</a></h1>


    <h2>
        <a href="#apidoc.element.bcrypt.compare" id="apidoc.element.bcrypt.compare">
        function <span class="apidocSignatureSpan">bcrypt.</span>compare
        <span class="apidocSignatureSpan">(data, hash, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compare(data, hash, cb) {
    if (typeof data === &#x27;function&#x27;) {
        return process.nextTick(function() {
            data(new Error(&#x27;data and hash arguments required&#x27;));
        });
    }

    if (typeof hash === &#x27;function&#x27;) {
        return process.nextTick(function() {
            hash(new Error(&#x27;data and hash arguments required&#x27;));
        });
    }

    // cb exists but is not a function
    // return a rejecting promise
    if (cb &#x26;&#x26; typeof cb !== &#x27;function&#x27;) {
        return promises.reject(new Error(&#x27;cb must be a function or null to return a Promise&#x27;));
    }

    if (!cb) {
        return promises.promise(compare, this, [data, hash]);
    }

    if (data == null || hash == null) {
        return process.nextTick(function() {
            cb(new Error(&#x27;data and hash arguments required&#x27;));
        });
    }

    if (typeof data !== &#x27;string&#x27; || typeof hash !== &#x27;string&#x27;) {
        return process.nextTick(function() {
            cb(new Error(&#x27;data and hash must be strings&#x27;));
        });
    }

    return bindings.compare(data, hash, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (typeof data !== &#x27;string&#x27; || typeof hash !== &#x27;string&#x27;) {
    return process.nextTick(function() {
        cb(new Error(&#x27;data and hash must be strings&#x27;));
    });
}

return bindings.<span class="apidocCodeKeywordSpan">compare</span>(data, hash, cb);
};

/// @param {String} hash extract rounds from this hash
/// @return {Number} the number of rounds used to encrypt a given hash
module.exports.getRounds = function getRounds(hash) {
if (hash == null) {
    throw new Error(&#x27;hash argument required&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bcrypt.compareSync" id="apidoc.element.bcrypt.compareSync">
        function <span class="apidocSignatureSpan">bcrypt.</span>compareSync
        <span class="apidocSignatureSpan">(data, hash)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compareSync(data, hash) {
    if (data == null || hash == null) {
        throw new Error(&#x27;data and hash arguments required&#x27;);
    }

    if (typeof data !== &#x27;string&#x27; || typeof hash !== &#x27;string&#x27;) {
        throw new Error(&#x27;data and hash must be strings&#x27;);
    }

    return bindings.compare_sync(data, hash);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

As with async, both techniques achieve the same end-result.

#### To check a password:

```javascript
// Load hash from your password DB.
bcrypt.<span class="apidocCodeKeywordSpan">compareSync</span>(myPlaintextPassword, hash); // true
bcrypt.compareSync(someOtherPlaintextPassword, hash); // false
```

### Why is async mode recommended over sync mode?
If you are using bcrypt on a simple script, using the sync mode is perfectly fine. However, if you are using bcrypt on a server,
the async mode is recommended. This is because the hashing done by bcrypt is CPU intensive, so the sync version will block the event
 loop and prevent your application from servicing any other inbound requests or events.

## API
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bcrypt.genSalt" id="apidoc.element.bcrypt.genSalt">
        function <span class="apidocSignatureSpan">bcrypt.</span>genSalt
        <span class="apidocSignatureSpan">(rounds, ignore, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function genSalt(rounds, ignore, cb) {
    // if callback is first argument, then use defaults for others
    if (typeof arguments[0] === &#x27;function&#x27;) {
        // have to set callback first otherwise arguments are overriden
        cb = arguments[0];
        rounds = 10;
    // callback is second argument
    } else if (typeof arguments[1] === &#x27;function&#x27;) {
        // have to set callback first otherwise arguments are overriden
        cb = arguments[1];
    }

    if (!cb) {
        return promises.promise(genSalt, this, [rounds, ignore]);
    }

    // default 10 rounds
    if (!rounds) {
        rounds = 10;
    } else if (typeof rounds !== &#x27;number&#x27;) {
        // callback error asynchronously
        return process.nextTick(function() {
            cb(new Error(&#x27;rounds must be a number&#x27;));
        });
    }

    crypto.randomBytes(16, function(error, randomBytes) {
        if (error) {
            cb(error);
            return;
        }

        bindings.gen_salt(rounds, randomBytes, cb);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return process.nextTick(function() {
            cb(new Error(&#x27;data must be a string and salt must either be a salt string or a number of rounds&#x27;));
        });
    }


    if (typeof salt === &#x27;number&#x27;) {
        return module.exports.<span class="apidocCodeKeywordSpan">genSalt</span>(salt, function(err, salt) {
            return bindings.encrypt(data, salt, cb);
        });
    }

    return bindings.encrypt(data, salt, cb);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bcrypt.genSaltSync" id="apidoc.element.bcrypt.genSaltSync">
        function <span class="apidocSignatureSpan">bcrypt.</span>genSaltSync
        <span class="apidocSignatureSpan">(rounds)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function genSaltSync(rounds) {
    // default 10 rounds
    if (!rounds) {
        rounds = 10;
    } else if (typeof rounds !== &#x27;number&#x27;) {
        throw new Error(&#x27;rounds must be a number&#x27;);
    }

    return bindings.gen_salt_sync(rounds, crypto.randomBytes(16));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    if (typeof data !== &#x27;string&#x27; || (typeof salt !== &#x27;string&#x27; &#x26;&#x26; typeof salt !== &#x27;number&#x27
;)) {
        throw new Error(&#x27;data must be a string and salt must either be a salt string or a number of rounds&#x27;);
    }

    if (typeof salt === &#x27;number&#x27;) {
        salt = module.exports.<span class="apidocCodeKeywordSpan">genSaltSync</span>(salt);
    }

    return bindings.encrypt_sync(data, salt);
};

/// hash data using a salt
/// @param {String} data the data to encrypt
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bcrypt.getRounds" id="apidoc.element.bcrypt.getRounds">
        function <span class="apidocSignatureSpan">bcrypt.</span>getRounds
        <span class="apidocSignatureSpan">(hash)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRounds(hash) {
    if (hash == null) {
        throw new Error(&#x27;hash argument required&#x27;);
    }

    if (typeof hash !== &#x27;string&#x27;) {
        throw new Error(&#x27;hash must be a string&#x27;);
    }

    return bindings.get_rounds(hash);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var start = Date.now();
bcrypt.genSalt(10, function(err, salt) {
console.log(&#x27;salt: &#x27; + salt);
console.log(&#x27;salt cb end: &#x27; + (Date.now() - start) + &#x27;ms&#x27;);
bcrypt.hash(&#x27;test&#x27;, salt, function(err, crypted) {
  console.log(&#x27;crypted: &#x27; + crypted);
  console.log(&#x27;crypted cb end: &#x27; + (Date.now() - start) + &#x27;ms&#x27;);
  console.log(&#x27;rounds used from hash:&#x27;, bcrypt.<span class="apidocCodeKeywordSpan">getRounds</span>(crypted));
  bcrypt.compare(&#x27;test&#x27;, crypted, function(err, res) {
    console.log(&#x27;compared true: &#x27; + res);
    console.log(&#x27;compared true cb end: &#x27; + (Date.now() - start) + &#x27;ms&#x27;);
  });
  bcrypt.compare(&#x27;bacon&#x27;, crypted, function(err, res) {
    console.log(&#x27;compared false: &#x27; + res);
    console.log(&#x27;compared false cb end: &#x27; + (Date.now() - start) + &#x27;ms&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bcrypt.hash" id="apidoc.element.bcrypt.hash">
        function <span class="apidocSignatureSpan">bcrypt.</span>hash
        <span class="apidocSignatureSpan">(data, salt, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hash(data, salt, cb) {
    if (typeof data === &#x27;function&#x27;) {
        return process.nextTick(function() {
            data(new Error(&#x27;data must be a string and salt must either be a salt string or a number of rounds&#x27;));
        });
    }

    if (typeof salt === &#x27;function&#x27;) {
        return process.nextTick(function() {
            salt(new Error(&#x27;data must be a string and salt must either be a salt string or a number of rounds&#x27;));
        });
    }

    // cb exists but is not a function
    // return a rejecting promise
    if (cb &#x26;&#x26; typeof cb !== &#x27;function&#x27;) {
        return promises.reject(new Error(&#x27;cb must be a function or null to return a Promise&#x27;));
    }

    if (!cb) {
        return promises.promise(hash, this, [data, salt]);
    }

    if (data == null || salt == null) {
        return process.nextTick(function() {
            cb(new Error(&#x27;data and salt arguments required&#x27;));
        });
    }

    if (typeof data !== &#x27;string&#x27; || (typeof salt !== &#x27;string&#x27; &#x26;&#x26; typeof salt !== &#x27;number&#x27;)) {
        return process.nextTick(function() {
            cb(new Error(&#x27;data must be a string and salt must either be a salt string or a number of rounds&#x27;));
        });
    }


    if (typeof salt === &#x27;number&#x27;) {
        return module.exports.genSalt(salt, function(err, salt) {
            return bindings.encrypt(data, salt, cb);
        });
    }

    return bindings.encrypt(data, salt, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### To hash a password:

Technique 1 (generate a salt and hash on separate function calls):

```javascript
bcrypt.genSalt(saltRounds, function(err, salt) {
    bcrypt.<span class="apidocCodeKeywordSpan">hash</span>(myPlaintextPassword, salt, function(err, hash) {
        // Store hash in your password DB.
    });
});
```

Technique 2 (auto-gen a salt and hash):
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bcrypt.hashSync" id="apidoc.element.bcrypt.hashSync">
        function <span class="apidocSignatureSpan">bcrypt.</span>hashSync
        <span class="apidocSignatureSpan">(data, salt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hashSync(data, salt) {
    if (data == null || salt == null) {
        throw new Error(&#x27;data and salt arguments required&#x27;);
    }

    if (typeof data !== &#x27;string&#x27; || (typeof salt !== &#x27;string&#x27; &#x26;&#x26; typeof salt !== &#x27;number&#x27;)) {
        throw new Error(&#x27;data must be a string and salt must either be a salt string or a number of rounds&#x27;);
    }

    if (typeof salt === &#x27;number&#x27;) {
        salt = module.exports.genSaltSync(salt);
    }

    return bindings.encrypt_sync(data, salt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### To hash a password:

Technique 1 (generate a salt and hash on separate function calls):

```javascript
var salt = bcrypt.genSaltSync(saltRounds);
var hash = bcrypt.<span class="apidocCodeKeywordSpan">hashSync</span>(myPlaintextPassword, salt);
// Store hash in your password DB.
```

Technique 2 (auto-gen a salt and hash):

```javascript
var hash = bcrypt.hashSync(myPlaintextPassword, saltRounds);
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bcrypt.promises" id="apidoc.module.bcrypt.promises">module bcrypt.promises</a></h1>


    <h2>
        <a href="#apidoc.element.bcrypt.promises.promise" id="apidoc.element.bcrypt.promises.promise">
        function <span class="apidocSignatureSpan">bcrypt.promises.</span>promise
        <span class="apidocSignatureSpan">(fn, context, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">promise = function (fn, context, args) {

    //can&#x27;t do anything without Promise so fail silently
    if (typeof Promise === &#x27;undefined&#x27;) {
        return;
    }

    if (!Array.isArray(args)) {
        args = Array.prototype.slice.call(args);
    }

    if (typeof fn !== &#x27;function&#x27;) {
        return Promise.reject(new Error(&#x27;fn must be a function&#x27;));
    }

    return new Promise(function(resolve, reject) {
        args.push(function(err, data) {
            if (err) {
                reject(err);
            } else {
                resolve(data);
            }
        });

        fn.apply(context, args);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// callback is second argument
} else if (typeof arguments[1] === &#x27;function&#x27;) {
    // have to set callback first otherwise arguments are overriden
    cb = arguments[1];
}

if (!cb) {
    return promises.<span class="apidocCodeKeywordSpan">promise</span>(genSalt, this, [rounds, ignore]);
}

// default 10 rounds
if (!rounds) {
    rounds = 10;
} else if (typeof rounds !== &#x27;number&#x27;) {
    // callback error asynchronously
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bcrypt.promises.reject" id="apidoc.element.bcrypt.promises.reject">
        function <span class="apidocSignatureSpan">bcrypt.promises.</span>reject
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reject = function (err) {

    // silently swallow errors if Promise is not defined
    // emulating old behavior
    if (typeof Promise === &#x27;undefined&#x27;) {
        return;
    }

    return Promise.reject(err);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        salt(new Error(&#x27;data must be a string and salt must either be a salt string or a number of rounds&#x27;));
    });
}

// cb exists but is not a function
// return a rejecting promise
if (cb &#x26;&#x26; typeof cb !== &#x27;function&#x27;) {
    return promises.<span class="apidocCodeKeywordSpan">reject</span>(new Error(&#x27;cb must be a function or null to return a
Promise&#x27;));
}

if (!cb) {
    return promises.promise(hash, this, [data, salt]);
}

if (data == null || salt == null) {
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
